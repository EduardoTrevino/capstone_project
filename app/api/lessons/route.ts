import { NextRequest, NextResponse } from "next/server";
import { supabase } from "@/lib/supabase"; // Ensure this is your admin client for writes

// Define the NEW structure for the JSON response we expect from OpenAI
const gameStepSchemaForAI = {
  type: "object",
  properties: {
    narrativeSteps: {
      type: "array",
      description: "Dialogue exchanges for this step. The first dialogue object can serve as the initial scene-setting for this part of the scenario. Subsequent dialogues react to choices or advance the narrative.",
      items: {
        type: "object",
        properties: {
          character: { type: "string", enum: ["Rani", "Ali", "Santosh", "Manju", "Rajesh", "Narrator"], description: "Character speaking." },
          pfp: { type: "string", description: "Full path to character pfp (e.g., /game/character_pfp/rani.png)." },
          text: { type: "string", description: "Dialogue text for this character." },
        },
        required: ["character", "pfp", "text"],
        additionalProperties: false,
      },
    },
    mainCharacterImage: {
      type: ["string", "null"],
      description: "Full path to main character image (e.g., /game/characters/ali.png) or null if no specific character is focused or image remains unchanged.",
    },
    scenarioContextNarrative: {
        type: "string",
        description: "A brief overarching narrative context for THE ENTIRE SCENARIO (max 3-4 sentences). This is generated ONCE at the start of a new scenario (when decision count is 0). For subsequent steps within the same scenario, this can be a very short reminder or omitted if narrativeSteps cover it."
    },
    scenarioKCsOverall: {
        type: "array",
        description: "List of 1 to 3 KC identifiers (e.g., 'KC6') that this ENTIRE SCENARIO primarily focuses on. Generated ONCE at the start of a new scenario. Pick from the provided KC list. These are the main learning objectives for the whole scenario.",
        items: { type: "string", description: "A KC identifier from the provided list." },
        minItems: 1,
        maxItems: 3,
    },
    decisionPoint: {
      type: ["object", "null"],
      description: "Present if the user needs to make a choice (max 3 per scenario). Null if scenarioComplete=true or if this step is purely narrative continuation without a new decision.",
      properties: {
        question: { type: "string", description: "The question or dilemma presented to the player for this decision point." },
        decisionPointKCsFocused: {
            type: "array",
            description: "List of 1 to 3 KC identifiers that this specific decision point primarily focuses on. Pick from the provided KC list.",
            items: { type: "string", description: "A KC identifier from the provided list." },
            minItems: 1,
            maxItems: 3
        },
        options: {
          type: "array",
          description: "Exactly 4 distinct options for the user to choose from.",
          items: {
            type: "object",
            properties: {
              text: { type: "string", description: "The text content of the option." },
              kc_impacts: {
                type: "array",
                description: "List of 1 to 3 KCs impacted by choosing this option, along with their scores. Pick KC identifiers from the provided list.",
                items: {
                  type: "object",
                  properties: {
                    kc_identifier: { type: "string", description: "The KC identifier (e.g., 'KC6', 'KC5') affected. MUST be one of the provided KCs." },
                    score: { type: "integer", description: "A small positive or negative integer score (e.g., between -3 and +3) representing the impact on this KC." }
                  },
                  required: ["kc_identifier", "score"],
                  additionalProperties: false
                },
                minItems: 1,
                maxItems: 3 // As per "1 < x < 4", allowing 1-3 for flexibility
              }
            },
            required: ["text", "kc_impacts"],
            additionalProperties: false
          },
          minItems: 4,
          maxItems: 4
        },
      },
      // If decisionPoint is an object, these fields are expected.
      // The 'null' type for decisionPoint handles its absence.
      required: ["question", "decisionPointKCsFocused", "options"],
      additionalProperties: false,
    },
    scenarioComplete: {
      type: "boolean",
      description: "Set to true when the entire scenario (narrative, 3 decisions) is finished.",
    },
  },
  required: [
    "narrativeSteps",
    "mainCharacterImage",
    // scenarioContextNarrative & scenarioKCsOverall are crucial for the first step of a new scenario
    // For subsequent steps, they might not be regenerated by AI if prompt guides it.
    // Let's make them required in schema, but prompt should guide when to fill them.
    "scenarioContextNarrative",
    "scenarioKCsOverall",
    "decisionPoint", // Key must be present, value can be null
    "scenarioComplete",
  ],
  additionalProperties: false,
};

interface KCDefinition { id: number; kc_identifier: string; name: string; description: string | null; }
interface MetricDefinition { id: number; name: string; data_type: string; min_value: number | null; max_value: number | null; initial_value: number; }
interface KCEffectLink { kc_id: number; metric_id: number; }
interface DefinitionsBundle {
    metrics: MetricDefinition[];
    kcEffects: KCEffectLink[];
    kcs: KCDefinition[];
    kcIdentifierToIdMap: Map<string, number>;
}

// Helper to get current game state from dialogue history
function getCurrentGameState(history: any[]) {
    let userDecisionsMade = 0;
    let lastDecisionIndex: number | null = null;
    history.forEach(entry => {
        if (entry.role === 'user' && entry.content?.includes("User chose decision index:")) {
            userDecisionsMade++;
            const match = entry.content.match(/index: (\d+)/);
            if (match) lastDecisionIndex = parseInt(match[1], 10);
        }
    });
    return { decisionCount: userDecisionsMade, lastDecisionIndex };
}

async function getDefinitionsBundle(): Promise<DefinitionsBundle> {
    const { data: metrics, error: metricsError } = await supabase
        .from('metrics')
        .select('id, name, data_type, min_value, max_value, initial_value');
    if (metricsError) throw new Error(`Failed to fetch metrics: ${metricsError.message}`);

    const { data: kcEffects, error: kcEffectsError } = await supabase
        .from('kc_metric_effects')
        .select('kc_id, metric_id');
    if (kcEffectsError) throw new Error(`Failed to fetch kc_metric_effects: ${kcEffectsError.message}`);

    const { data: kcs, error: kcsError } = await supabase
        .from('kcs')
        .select('id, kc_identifier, name, description');
    if (kcsError) throw new Error(`Failed to fetch KCs: ${kcsError.message}`);
    
    const kcIdentifierToIdMap = new Map((kcs || []).map(kc => [kc.kc_identifier, kc.id]));

    return {
        metrics: metrics || [],
        kcEffects: kcEffects || [],
        kcs: kcs || [],
        kcIdentifierToIdMap,
    };
}

export async function POST(req: NextRequest) {
  try {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) return NextResponse.json({ error: "Missing OPENAI_API_KEY" }, { status: 500 });

    const { userId, decisionIndex } = (await req.json()) as { userId?: string; decisionIndex?: number | null; };
    if (!userId) return NextResponse.json({ error: "Missing userId" }, { status: 400 });

    console.log(`[/api/lessons] User: ${userId}, DecisionIndex: ${decisionIndex}`);

    const { data: userRow, error: userError } = await supabase.from("users").select("name, focused_goal_id").eq("id", userId).single();
    if (userError || !userRow || !userRow.focused_goal_id) {
        console.error("User or focused_goal_id invalid:", userError);
        return NextResponse.json({ error: "User or focused_goal_id setup invalid" }, { status: 404 });
    }
    const userName = userRow.name;
    const focusedGoalId = userRow.focused_goal_id;

    const { data: goalRow, error: goalError } = await supabase
        .from("goals")
        .select("name, description, win_conditions_description")
        .eq("id", focusedGoalId)
        .single();
    if (goalError || !goalRow) {
        console.error("Goal not found:", goalError);
        return NextResponse.json({ error: "Goal not found" }, { status: 404 });
    }
    const { name: goalName, description: goalDescription, win_conditions_description: goalWinConditions } = goalRow;

    const { data: userGoalData, error: userGoalError } = await supabase
        .from("user_goals")
        .select("dialogue_history, attempts_for_current_goal_cycle, status")
        .eq("user_id", userId)
        .eq("goal_id", focusedGoalId)
        .single();

    // If no user_goals row, create one. This should ideally happen when user selects a goal.
    if (userGoalError && userGoalError.code === 'PGRST116') {
        console.warn(`No user_goals entry for user ${userId}, goal ${focusedGoalId}. Creating one.`);
        const { data: newUserGoal, error: insertError } = await supabase
            .from('user_goals')
            .insert({
                user_id: userId,
                goal_id: focusedGoalId,
                dialogue_history: [],
                attempts_for_current_goal_cycle: 0,
                status: 'active', // or 'pending_initial_scenario'
                progress: 0
            })
            .select()
            .single();
        if (insertError) {
            console.error("Failed to create user_goals entry:", insertError);
            return NextResponse.json({ error: "Failed to initialize user goal data." }, { status: 500 });
        }
        // @ts-ignore // Supabase types might not reflect the select immediately
        userGoalData = newUserGoal;
    } else if (userGoalError) {
        console.error("Error fetching user_goals data:", userGoalError);
        return NextResponse.json({ error: "Failed to fetch user goal data." }, { status: 500 });
    }

    const dialogueHistory = userGoalData?.dialogue_history ?? [];
    // attempts_for_current_goal_cycle from DB is count of *completed* attempts for this goal cycle.
    // scenarioAttemptNumber is the current one being played (1-indexed).
    const completedAttemptsForCycle = userGoalData?.attempts_for_current_goal_cycle ?? 0;
    const scenarioAttemptNumber = completedAttemptsForCycle + 1;


    const previousGameState = getCurrentGameState(dialogueHistory);
    // currentDecisionCount is the number of decisions made *within the current scenario attempt*.
    // It resets to 0 when a new scenario attempt begins.
    // If dialogueHistory is for a new attempt (e.g., after completing one), this count should be 0.
    // We might need to clear dialogueHistory or segment it per attempt for this count to be accurate for the *current* scenario.
    // For now, let's assume dialogueHistory is for the current ongoing scenario.
    // If a new scenario is starting (decisionIndex is null AND this is effectively attempt N, dp 0), we should ensure state is clean.
    let currentDecisionCount = previousGameState.decisionCount;
    if(decisionIndex === null && completedAttemptsForCycle === (scenarioAttemptNumber -1) && previousGameState.decisionCount === 3) {
        // This implies the previous scenario was completed, and this is a fresh start for a new attempt number.
        // Reset currentDecisionCount if the dialogue history reflects a fully completed previous scenario.
        // This logic can be complex. A simpler way: when a scenario completes, the frontend starts "fresh" for the next one.
        // The number of "user choice" messages for *this current scenario attempt* is what currentDecisionCount represents.
        // For simplicity, we'll rely on the frontend to reset `decisionCount` state for a new scenario.
        // The `previousGameState.decisionCount` reflects choices in the *entire dialogue history for this goal*.
        // This needs a more robust way to track decisions *per scenario attempt*.
        // Quick Fix for now: if decisionIndex is null and it's not the very first scenario of goal:
        // This means the previous scenario ended and we are starting a new one.
        // The `dialogueHistory` still contains old scenario. We need to clear it or segment it.
        // The `route.ts` should not manage this complex client-side state reset.
        // Let's assume the client sends decisionIndex: null when it *truly* starts a new scenario.
        // Then, previousGameState.decisionCount *from the existing dialogueHistory* would be for the prior completed one.
        // So, if decisionIndex is null, this is DP1, currentDecisionCount for AI prompt should be 0.
        if(decisionIndex === null) {
            currentDecisionCount = 0; // For the AI prompt, if it's a new scenario start.
        }
    }


    console.log(`[/api/lessons] Goal: ${goalName}. Scenario Attempt Number: ${scenarioAttemptNumber}. Effective decisions made for this new/ongoing scenario: ${currentDecisionCount}`);

    const definitions = await getDefinitionsBundle();
    const kcListForPrompt = definitions.kcs.map(kc => `- ${kc.kc_identifier}: ${kc.name} (${kc.description || 'General business skill'})`).join("\n");

    let totalKcChangesForThisTurn: Array<{ kc_id: number, kc_identifier: string, change: number }> = [];
    if (decisionIndex !== null && dialogueHistory.length > 0) {
        const lastAssistantResponseEntry = dialogueHistory.findLast((entry: { role: string; content: string }) => entry.role === 'assistant');
        if (lastAssistantResponseEntry) {
            try {
                const previousStepData = JSON.parse(lastAssistantResponseEntry.content);
                const chosenOption = previousStepData.decisionPoint?.options?.[decisionIndex?? 0];
                if (chosenOption?.kc_impacts?.length > 0) {
                    for (const impact of chosenOption.kc_impacts) {
                        const kc_id = definitions.kcIdentifierToIdMap.get(impact.kc_identifier);
                        if (kc_id) {
                            totalKcChangesForThisTurn.push({ kc_id, kc_identifier: impact.kc_identifier, change: impact.score });
                            const { error: kcScoreError } = await supabase.rpc('increment_user_kc_score', {
                                p_user_id: userId, p_kc_id: kc_id, p_increment_value: impact.score
                            });
                            if (kcScoreError) console.error(`Error RPC increment_user_kc_score for ${impact.kc_identifier}:`, kcScoreError);
                        } else console.warn(`KC ID for ${impact.kc_identifier} not found in map.`);
                    }
                    console.log(`[/api/lessons] Processed KC impacts for decision ${decisionIndex}:`, totalKcChangesForThisTurn);
                }
            } catch (e) { console.error("Error parsing previous AI response for KC impacts:", e); }
        }
    }

    let metricChangesSummary: Array<{ metricName: string, change: number, unit: string, finalValue: number }> = [];
    if (totalKcChangesForThisTurn.length > 0) {
        for (const kcChange of totalKcChangesForThisTurn) {
            const affectedMetricLinks = definitions.kcEffects.filter(link => link.kc_id === kcChange.kc_id);
            for (const link of affectedMetricLinks) {
                const metricDef = definitions.metrics.find(m => m.id === link.metric_id);
                if (!metricDef) continue;

                let rawMetricChange = 0; let unit = "";
                switch (metricDef.name) {
                    case 'Revenue': rawMetricChange = kcChange.change * 500; unit = "₹"; break; // Increased impact
                    case 'Customer Satisfaction': rawMetricChange = kcChange.change * 5; unit = "%"; break;
                    case 'Reputation': rawMetricChange = kcChange.change * 0.25; unit = " stars"; break;
                    case 'Ethical Decision Making': rawMetricChange = kcChange.change * 7; unit = "%"; break; // Slightly higher impact
                    case 'Risk-Taking': rawMetricChange = kcChange.change * 10; unit = "%"; break;
                    default: rawMetricChange = kcChange.change * 2; unit = "%";
                }

                const { data: metricScoreRow, error: fetchError } = await supabase.from('user_metric_scores').select('current_value').eq('user_id', userId).eq('metric_id', metricDef.id).single();
                let currentMetricValue = metricDef.initial_value; // Fallback to default initial_value
                if (fetchError && fetchError.code !== 'PGRST116') console.error(`Error fetching metric ${metricDef.name}:`, fetchError);
                if (metricScoreRow) currentMetricValue = parseFloat(metricScoreRow.current_value as any);
                
                let newMetricValue = currentMetricValue + rawMetricChange;
                if (metricDef.min_value !== null) newMetricValue = Math.max(Number(metricDef.min_value), newMetricValue);
                if (metricDef.max_value !== null) newMetricValue = Math.min(Number(metricDef.max_value), newMetricValue);
                const actualChangeApplied = parseFloat((newMetricValue - currentMetricValue).toFixed(2)); // Round to 2 decimal places

                const { error: updateMetricError } = await supabase.from('user_metric_scores').upsert({
                    user_id: userId, metric_id: metricDef.id, current_value: newMetricValue, last_updated_at: new Date().toISOString()
                }, { onConflict: 'user_id, metric_id' });

                if (updateMetricError) console.error(`Error updating metric ${metricDef.name}:`, updateMetricError);
                else {
                    console.log(`[/api/lessons] Metric ${metricDef.name} ${currentMetricValue} -> ${newMetricValue} (Change: ${actualChangeApplied}) for KC ${kcChange.kc_identifier}`);
                    const existingSummary = metricChangesSummary.find(s => s.metricName === metricDef.name);
                    if (existingSummary) {
                        existingSummary.change = parseFloat((existingSummary.change + actualChangeApplied).toFixed(2));
                        existingSummary.finalValue = newMetricValue;
                    } else {
                        metricChangesSummary.push({ metricName: metricDef.name, change: actualChangeApplied, unit, finalValue: newMetricValue });
                    }
                }
            }
        }
    }
    // --- Build the dynamic system prompt ---
    // The system prompt needs to adapt based on whether it's a new scenario or continuation
    let systemPrompt = `You are an expert scenario generator for an educational business simulation game.
Player: "${userName}".
Current Learning Goal: "${goalName}". Goal Description: "${goalDescription}". Win Conditions: "${goalWinConditions}".
This is Scenario Attempt number ${scenarioAttemptNumber} for this goal (out of 3 attempts, each with a unique narrative).

Available Knowledge Components (KCs) for you to reference and assign scores to:
${kcListForPrompt}

Scenario Structure:
A full scenario consists of an initial narrative, followed by 3 decision points, and a concluding narrative.
- Start of Scenario (0 decisions made): Generate \`scenarioContextNarrative\`, \`scenarioKCsOverall\`, initial \`narrativeSteps\`, and the FIRST \`decisionPoint\`. \`scenarioComplete\` is false.
- Mid-Scenario (1 or 2 decisions made): Generate follow-up \`narrativeSteps\` based on the last choice, and the NEXT \`decisionPoint\`. \`scenarioContextNarrative\` & \`scenarioKCsOverall\` should be omitted or very brief reminders, as they were set at the start. \`scenarioComplete\` is false.
- End of Scenario (3 decisions made): Generate FINAL \`narrativeSteps\` concluding the story. \`decisionPoint\` MUST be null. \`scenarioComplete\` is true. \`scenarioContextNarrative\` & \`scenarioKCsOverall\` are omitted.

Current State for this Scenario Attempt:
- Decisions successfully made by user so far in THIS scenario: ${currentDecisionCount}
${previousGameState.lastDecisionIndex !== null ? `- User's previous decision index choice: ${previousGameState.lastDecisionIndex}` : ''}
${decisionIndex !== null ? `- User has JUST chosen decision option index: ${decisionIndex} for the decision point that was presented.` : (currentDecisionCount === 0 ? '- User is starting this new scenario attempt.' : '- User is continuing the scenario.')}

Your Task: Generate the JSON for the *next* step of the scenario. Adhere STRICTLY to the provided JSON schema.

Detailed Instructions:
1.  Narrative & Dialogue:
    *   \`scenarioContextNarrative\`: Generate a compelling, unique overarching story for this scenario attempt number ${scenarioAttemptNumber} ONLY IF \`currentDecisionCount\` is 0. Keep it to 2-4 sentences. For subsequent steps, make it very brief (e.g., "Continuing from your choice...") or an empty string if covered by \`narrativeSteps\`.
    *   \`narrativeSteps\`: Provide engaging dialogue. Characters should react realistically to prior choices if applicable. Use the provided character list (Rani, Ali, Santosh, Manju, Rajesh, Narrator). Ensure pfp paths are correct (e.g., /game/character_pfp/rani.png).
    *   \`mainCharacterImage\`: Use full paths (e.g., /game/characters/ali.png) or null.
2.  KCs:
    *   \`scenarioKCsOverall\`: IF \`currentDecisionCount\` is 0, select 1-3 KC identifiers from the list that this entire scenario attempt will focus on. Otherwise, this should be an empty array or omitted if schema allows (for now, schema requires it, so provide an empty array if not first step or make schema allow null).
    *   \`decisionPointKCsFocused\`: For each \`decisionPoint\`, select 1-3 relevant KC identifiers.
    *   \`kc_impacts\` (within each option): Assign 1-3 KCs. Scores should be small integers (e.g., -2, -1, 0, 1, 2, max -3 to +3). Positive scores are good for the KC, negative are detrimental.
3.  Decision Points & Options:
    *   If \`currentDecisionCount\` < 3, a \`decisionPoint\` object is required.
    *   If \`currentDecisionCount\` == 3, \`decisionPoint\` MUST be null, and \`scenarioComplete\` MUST be true.
    *   Each \`decisionPoint\` must have a \`question\` and exactly 4 \`options\`. Each option needs \`text\` and \`kc_impacts\`.
    * Basically 
    *   \`decisionPoint\`:
        - IF \`currentDecisionCount\` is 0, generate the 1st DP.
        - IF \`currentDecisionCount\` is 1, generate the 2nd DP.
        - IF \`currentDecisionCount\` is 2, generate the 3rd DP.
        - IF \`currentDecisionCount\` is 3, \`decisionPoint\` MUST be null, \`scenarioComplete\` MUST be true.
4.  Schema Adherence: Output MUST be a single, valid JSON object matching the schema. All required fields must be present.

Character PFP and Image Paths:
- Rani: pfp=/game/character_pfp/rani.png, image=/game/characters/rani.png
- Ali: pfp=/game/character_pfp/ali.png, image=/game/characters/ali.png
- Santosh: pfp=/game/character_pfp/santosh.png, image=/game/characters/santosh.png
- Manju: pfp=/game/character_pfp/manju.png, image=/game/characters/manju.png
- Rajesh: pfp=/game/character_pfp/rajesh.png, image=/game/characters/rajesh.png
- Narrator: pfp=/game/character_pfp/narrator.png (image might be null or a generic scene)

Scenario Characters:
- Rani: She is a successful Entrepreneur who is always willing to provide help and guidance. Her persona is exuberant, encouraging, and quick to offer both positive affirmation and constructive feedback.
- Ali: He is a partner to the player. He is the entrepreneurial vendor who introduces advanced drone technology and leasing models. He also provides the hardware for missions, tasks, and challenges in the game.
- Santosh: He is a customer and farmer by profession. He also voices the other customers’ feedback and needs on their behalf. His persona is that of a wise elder and community figure with a strong sense of ethics and social responsibility. 
- Manju: She is an official from a government-backed program or a funding agency that incentivizes agritech innovations—particularly drone leasing. Her role is to acts as a resource for subsidies, grants, or low-interest loans to support entrepreneurs who meet certain criteria (e.g., community impact, sustainable practices).
- Rajesh: He is a friendly rival and occasional co-learner, representing the typical rural youth eager to learn new tech skills. His role is to encourage healthy competition, which can drive engagement.


`;

    // Conditional prompt adjustment for first step vs. continuation
    if (currentDecisionCount === 0 && decisionIndex === null) {
        systemPrompt += "\nTask: Generate the initial context, overall KCs, narrative, and the 1st decision point.";
    } else if (decisionIndex !== null) {
        if (currentDecisionCount < 2) { // User made 1st (count=0) or 2nd (count=1) choice. AI generates DP2 or DP3.
            systemPrompt += `\nTask: User chose option index ${decisionIndex} for their ${currentDecisionCount + 1}st/nd decision. Generate narrative consequences and the NEXT decision point. \`scenarioKCsOverall\` must be [].`;
        } else if (currentDecisionCount === 2) { // User made 3rd choice (count=2). AI concludes.
            systemPrompt += `\nTask: User chose option index ${decisionIndex} for their THIRD decision. Generate concluding narrative. \`decisionPoint\` = null, \`scenarioComplete\` = true. \`scenarioKCsOverall\` must be [].`;
        }
    } else if (currentDecisionCount === 3 && decisionIndex === null) {
        // This case might occur if page reloads after 3rd decision but before summary. AI should provide conclusion.
        systemPrompt += `\nTask: User has completed 3 decisions. Generate concluding narrative. \`decisionPoint\` = null, \`scenarioComplete\` = true. \`scenarioKCsOverall\` must be [].`;
    }


    const messagesForOpenAI = [{ role: "system", content: systemPrompt.trim() }];
    // Give some history, but not too much to confuse the current state context for AI.
    const relevantHistory = dialogueHistory.slice(-4); // Last 2 user actions and 2 AI responses
    messagesForOpenAI.push(...relevantHistory);

    if (decisionIndex !== null) {
        messagesForOpenAI.push({ role: "user", content: `I chose decision option index: ${decisionIndex}. Based on the Current State (${currentDecisionCount} decisions made before this choice), what happens next?` });
    } else if (currentDecisionCount === 0) {
        messagesForOpenAI.push({ role: "user", content: "Start this new scenario attempt." });
    } else if (currentDecisionCount === 3) {
        messagesForOpenAI.push({ role: "user", content: "Provide the conclusion for this scenario." });
    }
    
    console.log("[/api/lessons] Messages for OpenAI =>", JSON.stringify(messagesForOpenAI, null, 2));

    const payload = {
      model: "gpt-4o-2024-08-06", // Ensure you use a model supporting json_schema output
      messages: messagesForOpenAI,
      response_format: {
        type: "json_schema",
        json_schema: { name: "game_step_generation", description: "Generates a step in the game scenario, including narrative, KCs, and decision points.", schema: gameStepSchemaForAI, strict: true }
      },
      temperature: 0.7,
    };

    const response = await fetch("https://api.openai.com/v1/chat/completions", { method: "POST", headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` }, body: JSON.stringify(payload) });

    if (!response.ok) {
        const errorText = await response.text();
        console.error("[/api/lessons] OpenAI error response:", response.status, errorText);
        return NextResponse.json({ error: `OpenAI API Error: ${response.statusText} - ${errorText}` }, { status: response.status });
    }

    const data = await response.json();
    const content = data?.choices?.[0]?.message?.content;

    if (!content) {
        console.error("[/api/lessons] No content in OpenAI response:", data);
        return NextResponse.json({ error: "No content returned from AI model." }, { status: 500 });
    }

    let parsedScenarioStep;
    try {
      parsedScenarioStep = JSON.parse(content);
    } catch (err) {
      console.error("[/api/lessons] Failed to parse JSON from AI:", content, err);
      return NextResponse.json({ error: "Could not parse valid JSON from AI.", raw_content: content }, { status: 500 });
    }
    
    console.log("[/api/lessons] Parsed Scenario Step from AI =>", JSON.stringify(parsedScenarioStep, null, 2));
    // --- Storing the generated scenario into new DB structure ---
    // This is a complex part. We need to handle new scenario creation vs. new decision point for an existing scenario.
    // For simplicity, let's assume each call to /api/lessons *could* generate a full scenario structure,
    // but the frontend will only display parts of it. The `dialogue_history` in `user_goals` will store the AI's raw JSON output.
    // The actual saving of granular scenario parts (scenarios, decision_points, options, kc_effects) to their dedicated tables
    // should happen when a scenario is *first* generated for an attempt.

    // If it's the start of a new scenario (currentDecisionCount === 0 and decisionIndex is null)
    // then we save the main scenario shell and its associated KCs.
    // Decision points and options are saved as they are generated.

    // For now, just update dialogue_history and progress. Granular saving is a larger task.
    const newDialogueHistoryEntry = { role: "assistant", content }; // The raw JSON from AI
    const updatedDialogueHistory = [...dialogueHistory];
    if (decisionIndex !== null) { // Add user's explicit choice if one was made
        updatedDialogueHistory.push({ role: "user", content: `User chose decision index: ${decisionIndex}` });
    }
    updatedDialogueHistory.push(newDialogueHistoryEntry);

    // Goal Progress & Status
    let goalProgressValue = 0;
    let goalStatus = userGoalData?.status || 'active';
    let scenarioJustCompleted = parsedScenarioStep.scenarioComplete;
    let updatedCompletedAttemptsForCycle = completedAttemptsForCycle;

    if (scenarioJustCompleted) {
        updatedCompletedAttemptsForCycle++;
    }

    const { data: allCurrentUserMetricScoresData } = await supabase.from('user_metric_scores').select('metrics(name), current_value').eq('user_id', userId);
    const currentUserMetrics = new Map(allCurrentUserMetricScoresData?.map(m => [m.metrics.name, parseFloat(m.current_value as any)]));
    console.log("[/api/lessons] Current User Metrics for Win Condition Check:", Object.fromEntries(currentUserMetrics));

    let goalAchieved = false;
    // TODO: Implement structured win condition parsing or hardcode per goalName
    if (goalWinConditions) {
        try {
            // Example: "Profit >= 2000 AND Customer Satisfaction >= 50 AND Reputation >= 3.0"
            const conditions = goalWinConditions.split("AND").map(c => c.trim());
            let allConditionsMet = true;
            let conditionsProgress = conditions.map(() => 0); // Progress for each condition

            for (let i = 0; i < conditions.length; i++) {
                const condition = conditions[i];
                const match = condition.match(/(.+?)\s*([><=!]+)\s*([\d.]+)/);
                if (match) {
                    const metricName = match[1].trim();
                    const operator = match[2];
                    const targetValue = parseFloat(match[3]);
                    const currentValue = currentUserMetrics.get(metricName) ?? 0;
                    let conditionMet = false;
                    if (operator === ">=") conditionMet = currentValue >= targetValue;
                    else if (operator === "<=") conditionMet = currentValue <= targetValue;
                    else if (operator === ">") conditionMet = currentValue > targetValue;
                    else if (operator === "<") conditionMet = currentValue < targetValue;
                    else if (operator === "==" || operator === "=") conditionMet = currentValue === targetValue;
                    
                    if (!conditionMet) allConditionsMet = false;

                    // Partial progress for this condition
                    if (targetValue > 0) { // Avoid division by zero for non-positive targets
                        let progressForCondition = (currentValue / targetValue) * (100 / conditions.length);
                        if (operator.includes("=")) { // For >= or <=, cap at 100% for this part
                            progressForCondition = Math.min(100 / conditions.length, progressForCondition);
                        }
                        conditionsProgress[i] = Math.max(0, progressForCondition); // Ensure no negative progress
                    } else if (currentValue === targetValue && (operator === "==" || operator === "=")) {
                        conditionsProgress[i] = 100 / conditions.length;
                    }

                    console.log(`[WinCheck] Metric: ${metricName}, Current: ${currentValue}, Operator: ${operator}, Target: ${targetValue}, Met: ${conditionMet}, ProgressPart: ${conditionsProgress[i]}`);
                } else {
                    allConditionsMet = false; // Invalid condition format
                    console.warn(`Invalid win condition format: ${condition}`);
                }
            }
            goalAchieved = allConditionsMet;
            goalProgressValue = Math.round(conditionsProgress.reduce((sum, p) => sum + p, 0));

        } catch (e) {
            console.error("Error parsing win_conditions_description:", e);
            // Fallback progress calculation if parsing fails
            goalProgressValue = Math.min(95, Math.round(((currentDecisionCount + (decisionIndex !== null ? 1 : 0)) / 3) * 90) + 5);
        }
    } else { // Fallback if no win_conditions_description
        goalProgressValue = Math.min(95, Math.round(((currentDecisionCount + (decisionIndex !== null ? 1 : 0)) / 3) * 90) + 5);
    }


    if (goalAchieved) {
        goalStatus = 'completed';
        goalProgressValue = 100; // Ensure 100% on achievement
        console.log(`[/api/lessons] Goal "${goalName}" ACHIEVED by user ${userId}!`);
    } else if (scenarioJustCompleted && updatedCompletedAttemptsForCycle >= 3) {
        goalStatus = 'failed_needs_retry';
        console.log(`[/api/lessons] Goal "${goalName}" NOT achieved after 3 attempts. Status: ${goalStatus}`);
    } else if (scenarioJustCompleted) {
        console.log(`[/api/lessons] Scenario attempt ${updatedCompletedAttemptsForCycle} for goal "${goalName}" completed. Goal not yet achieved.`);
        // goalProgressValue is already calculated based on metrics
    }
    // If not scenarioJustCompleted, goalProgressValue is also based on metrics or decision count as fallback.
    goalProgressValue = Math.min(100, Math.max(0, goalProgressValue));


    const { error: upsertError } = await supabase.from("user_goals").upsert({
        user_id: userId, goal_id: focusedGoalId, dialogue_history: updatedDialogueHistory,
        progress: goalProgressValue, status: goalStatus,
        attempts_for_current_goal_cycle: updatedCompletedAttemptsForCycle,
        updated_at: new Date().toISOString(),
    }, { onConflict: "user_id,goal_id" });

    if (upsertError) console.error("Error upserting user_goals:", upsertError);

    return NextResponse.json({
        scenarioStep: parsedScenarioStep,
        scenarioAttemptNumber: scenarioAttemptNumber,
        metricChangesSummary: metricChangesSummary,
        goalStatusAfterStep: goalStatus,
        currentGoalProgress: goalProgressValue,
        currentDecisionCountAfterStep: currentDecisionCount + (decisionIndex !== null ? 1 : 0) // For frontend to update its own decision counter
    });

  } catch (err: any) {
    console.error("[/api/lessons] Unhandled Route error =>", err, err.stack);
    return NextResponse.json({ error: err.message || "An internal server error occurred." }, { status: 500 });
  }
}
    
    // --- TODO: More granular saving logic ---
    // This is where you'd parse `parsedScenarioStep` and save to `scenarios`, `decision_points`, `options`, `option_kc_effects` etc.
    // This would typically happen:
    // 1. When a new scenario `scenarioContextNarrative` is generated (currentDecisionCount == 0):
    //    - Create a new row in `scenarios` table.
    //    - Link `scenarioKCsOverall` to `scenario_targeted_kcs`.
    // 2. When a `decisionPoint` is generated:
    //    - Create a new row in `decision_points` linked to the current scenario.
    //    - Link `decisionPointKCsFocused` to `decision_point_focused_kcs`.
    //    - For each option in `decisionPoint.options`:
    //        - Create a row in `options`.
    //        - For each `kc_impact` in the option:
    //            - Create a row in `option_kc_effects`.
    // This requires careful management of scenario IDs and potentially passing the current `scenario.id` if continuing.
    // For now, the response is sent back, and the game page consumes it. The `dialogue_history` holds the full AI output.


